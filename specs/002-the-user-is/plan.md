# Implementation Plan: Expresso: Enhanced CLI and Input Handling

**Branch**: `002-the-user-is` | **Date**: 2025-10-14 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/002-the-user-is/spec.md`

**Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

This plan outlines the implementation of an interactive command-line tool for evaluating mathematical and logical expressions. The core of the tool will be an expression evaluation library written in ANSI C17. The parser for the expression language will be generated by ANTLR4 with a C++ target, which will be integrated into the C17 application. The project will be built using CMake.

## Technical Context

**Language/Version**: ANSI C17 (Core application), C++17 (for ANTLR-generated parser)
**Primary Dependencies**: ANTLR4 (v4.13.2+, Parser Generator)
**Storage**: N/A (In-memory evaluation)
**Testing**: GoogleTest (v1.17.0+, for C++) and a custom assert framework (for C), managed by CTest. A dedicated integration smoke test for the C-to-C++ parser interface is required.
**Target Platform**: Linux, macOS, Windows (CLI)
**Project Type**: Single project (Library + CLI)
**Performance Goals**: < 50ms average evaluation time, < 10MB peak memory
**Constraints**: Immutable expressions (no assignments or pointers), sandboxed execution, fixed input buffers
**Scale/Scope**: Single-user interactive CLI tool

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- **I. Library-First**: **PASS**. The evaluator will be a self-contained library (libexpresso.a).
- **II. CLI Interface**: **PASS**. The primary interface is a CLI (expresso).
- **III. Test-First**: **PASS**. TDD is a required part of the implementation phase.
- **V. Testing Standards**: **PASS**. The plan includes unit and integration testing.
- **X. Simplicity**: **VIOLATION**. The use of two different languages (C and C++) introduces complexity.
- **Additional Constraints**: **VIOLATION**. The constitution states "All code... is written in ANSI C17," but the plan requires C++ for the ANTLR parser.

The violations are justified in the Complexity Tracking section below.

**Resolution**: The constitutional violations are formally acknowledged and accepted for this feature, as the use of C++ for the ANTLR parser is a direct trade-off for development speed and parser correctness, which outweighs the complexity cost of a multi-language setup in this specific context.

## Project Structure

### Documentation (this feature)

```
specs/002-the-user-is/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```
src/
├── cli/          # Main application entry point
├── core/         # Core C17 evaluation logic (the library)
└── parser/       # C++ ANTLR parser and C wrapper
  └── generated/  # ANTLR-generated C++ code

tests/
├── integration/  # Tests for the CLI and library integration
└── unit/         # Unit tests for core and parser
  ├── core/
  └── parser/

# External dependencies
vendor/
└── antlr4/       # ANTLR4 C++ runtime source

# Build files
CMakeLists.txt
```

**Structure Decision**: The project will follow the "Single project" structure. The `src` directory is divided into `cli` (the user-facing application), `core` (the main C17 library), and `parser` (the C++ ANTLR components). This separation isolates the different languages and concerns.

## Build Configuration

### Compiler Flags (Clang)
- **Debug**: `-g -O0 -DDEBUG -Wall -Wextra -pedantic`
- **Release**: `-O3 -DNDEBUG -Wall -Wextra -pedantic`

### Platform-Specific Build Notes
- **Linux/macOS**: Standard Makefiles or Ninja build. No special configuration expected.
- **Windows**: Build via Visual Studio solution generated by CMake. The `extern "C"` wrapper is critical for handling MSVC name mangling.

## Build Process and Linking

The build is managed by CMake and follows these general steps:

1.  **Prerequisite Check**: The CMake configuration will check for the presence of the ANTLR4 JAR file. If not found, the configuration will fail with a clear error message.
2.  **Parser Generation**: CMake will invoke `java -jar antlr-4.13.2-complete.jar ...` to generate the C++ parser and lexer from `src/parser/Expresso.g4`. This step only runs if `Expresso.g4` or the ANTLR JAR has changed.
3.  **Static Library Compilation**:
    - The core C17 evaluation logic (`src/core/`) is compiled into a static library (`libexpresso_core.a`).
    - The ANTLR C++ runtime, the generated parser, and the C wrapper (`src/parser/`) are compiled into a second static library (`libexpresso_parser.a`).
4.  **Executable Linking**: The main application entry point (`src/cli/main.c`) is compiled and linked against the two static libraries (`libexpresso_core.a` and `libexpresso_parser.a`) to create the final `expresso` executable.

## Complexity Tracking

*Fill ONLY if Constitution Check has violations that must be justified*

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| Use of C++ in a C17 project | The ANTLR4 parser generator, specified in the initial requirements, does not have an ANSI C target. C++ is the most mature and well-supported target that can be cleanly integrated with a C application. | Writing a robust expression parser by hand is a significantly more complex and error-prone task than using a mature tool like ANTLR. The maintenance overhead of a manual parser would be much higher. |
