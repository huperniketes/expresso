#include "parser_wrapper.h"
// Include ANTLR-generated sources (from build/generated)
#include "ExpressoLexer.h"  // Generated by ANTLR
#include "ExpressoParser.h" // Generated by ANTLR
#include "antlr4-runtime.h"

#include <iostream> // For basic error output
#include <string>

// Define the opaque context structure
struct ExpressoParserContext {
    // ANTLR components
    antlr4::ANTLRInputStream input;
    ExpressoLexer lexer;
    antlr4::CommonTokenStream tokens;
    ExpressoParser parser;

    // Constructor to initialize ANTLR components
    ExpressoParserContext() :
        input(""), // Initialize with empty string
        lexer(&input),
        tokens(&lexer),
        parser(&tokens)
    {
        // Configure error handling if needed
        // parser.removeErrorListeners();
        // parser.addErrorListener(new MyErrorListener());
    }
};

// Define the parse tree wrapper structure
struct ExpressoParseTree {
    ExpressoParser::ExpressionContext* ctx;
    std::string text;  // Cache the text to return a stable char*

    explicit ExpressoParseTree(ExpressoParser::ExpressionContext* context) 
        : ctx(context) {
        if (ctx) {
            text = ctx->getText();
        }
    }
};

ExpressoParserContext* expresso_parser_create(void) {
    return new ExpressoParserContext();
}

ExpressoParseTree* expresso_parser_parse(ExpressoParserContext* ctx, const char* expression_str) {
    if (!ctx || !expression_str) {
        return nullptr;
    }

    // Reset input stream with the new expression
    ctx->input.load(expression_str);
    ctx->lexer.setInputStream(&ctx->input);
    ctx->tokens.setTokenSource(&ctx->lexer);
    ctx->parser.setTokenStream(&ctx->tokens);

    // Reset parser state
    ctx->parser.reset();

    // Parse the expression
    ExpressoParser::ExpressionContext* tree = ctx->parser.expression();

    // Check for syntax errors
    if (ctx->parser.getNumberOfSyntaxErrors() > 0) {
        std::cerr << "Syntax Error(s) detected." << std::endl;
        return nullptr;
    }

    return new ExpressoParseTree(tree);
}

const char* expresso_tree_get_text(ExpressoParseTree* tree) {
    if (!tree) return nullptr;
    return tree->text.c_str();
}

int expresso_tree_get_type(ExpressoParseTree* tree) {
    if (!tree || !tree->ctx) return -1;
    return tree->ctx->getRuleIndex();
}

void expresso_tree_destroy(ExpressoParseTree* tree) {
    delete tree;
}

void expresso_parser_destroy(ExpressoParserContext* ctx) {
    delete ctx;
}
