#include "parser_wrapper.h"
#include "ExpressoLexer.h" // Generated by ANTLR
#include "ExpressoParser.h" // Generated by ANTLR
#include "antlr4-runtime.h"

#include <iostream> // For basic error output

// Define the opaque context structure
struct ExpressoParserContext {
    // ANTLR components
    antlr4::ANTLRInputStream input;
    ExpressoLexer lexer;
    antlr4::CommonTokenStream tokens;
    ExpressoParser parser;

    // Constructor to initialize ANTLR components
    ExpressoParserContext() :
        input(""), // Initialize with empty string
        lexer(&input),
        tokens(&lexer),
        parser(&tokens)
    {
        // Configure error handling if needed
        // parser.removeErrorListeners();
        // parser.addErrorListener(new MyErrorListener());
    }
};

ExpressoParserContext* expresso_parser_create() {
    return new ExpressoParserContext();
}

ExpressoParser::ExpressionContext* expresso_parser_parse(ExpressoParserContext* ctx, const char* expression_str) {
    if (!ctx || !expression_str) {
        // In C++, returning nullptr is common for error.
        // In C, this would be a problem, but the C wrapper handles it.
        return nullptr;
    }

    // Reset input stream with the new expression
    ctx->input.load(expression_str);
    ctx->lexer.setInputStream(&ctx->input);
    ctx->tokens.setTokenSource(&ctx->lexer);
    ctx->parser.setTokenStream(&ctx->tokens);

    // Reset parser state
    ctx->parser.reset();

    // Parse the expression
    ExpressoParser::ExpressionContext* tree = ctx->parser.expression();

    // Check for syntax errors
    if (ctx->parser.getNumberOfSyntaxErrors() > 0) {
        std::cerr << "Syntax Error(s) detected." << std::endl;
        return nullptr; // Indicate error by returning nullptr
    }

    // For now, just print the parse tree (for debugging)
    // std::cout << tree->toStringTree(&ctx->parser) << std::endl;

    return tree; // Success, return the parse tree
}

void expresso_parser_destroy(ExpressoParserContext* ctx) {
    delete ctx;
}
